# 第 3 章 查找

## 3.1 符号表

符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，即将一组新的键值对存入表中；查找(get)，即根据给定的键得到相应的值。

### 3.1.1 API

|                 |                           |                                                  |
| --------------: | :------------------------ | :----------------------------------------------- |
|    public class | ST\<Key, value\>          |                                                  |
|                 | ST()                      | 创建一张符号表                                   |
|            void | put(Key key, Value value) | 将键值对存入表中（若值为空则将键 key 从表中删除) |
|           Value | get(Key key)              | 获取键 Key 对应的值（若键 key 不存在则抬 null)   |
|            void | delete(Key key)           | 从表中删去键 key（及其对应的值）                 |
|         boolean | contains(Key key)         | 键 key 在表中是否有对应的值                      |
|         boolean | isEmpty()                 | 表是否为空                                       |
|             int | size()                    | 表中的键值对数量                                 |
| Iterable\<Key\> | keys()                    | 表中的所有键的集合                               |

1. 泛型

2. 重复的键

    所有实现遵循以下规则：

    - 每个键只对应着一个值（表中不允许存在重复的键）
    - 每当代码向表中存入的键值对和表中已有的键冲突时，新的值会替代旧的值

3. 空键(null)

    键不能为空。

4. 空值(null)

    不允许有空值。

5. 删除操作

    - 延时删除：将键对应的值置为空，在某个时候删去所有值为空的健。
    - 即时删除：立刻从表中删除指定的键。

6. 便携方法

7. 迭代

8. 键的等价性

### 3.1.2 有序符号表

有序泛型符号表 API

|                 |                                            |                                                  |
| --------------: | :----------------------------------------- | :----------------------------------------------- |
|    public class | ST\<Key extends Comparable\<key\>, Value\> |                                                  |
|                 | ST()                                       | 创建一张符号表                                   |
|            void | put(Key key, Value value)                  | 将键值对存入表中（若值为空则将键 key 从表中删除) |
|           Value | get(Key key)                               | 获取键 Key 对应的值（若键 key 不存在则抬 null)   |
|            void | delete(Key key)                            | 从表中删去键 key（及其对应的值）                 |
|         boolean | contains(Key key)                          | 键 key 在表中是否有对应的值                      |
|         boolean | isEmpty()                                  | 表是否为空                                       |
|             int | size()                                     | 表中的键值对数量                                 |
|             Key | min()                                      | 最小的键                                         |
|             Key | max()                                      | 最大的键                                         |
|             Key | floor(Key key)                             | 小于等于 key 的最大键                            |
|             Key | ceiling(key key)                           | 大于等于 key 的最小键                            |
|             int | rank(Key key)                              | 小于 key 的键的数量                              |
|             Key | select(int k)                              | 排名为 k 的键                                    |
|            void | deleteMin()                                | 删除最小的键                                     |
|            void | deleteMax()                                | 删除最大的键                                     |
|             int | size(Key lo, Key hi)                       | \[lo..hi\]之间键的数量                           |
| Iterable\<Key\> | keys(Key lo, Key hi)                       | \[lo..hi]之间的所有键，已排序                    |
| Iterable\<Key\> | keys()                                     | 所有键的集合，已排序                             |

1. 最大键和最小键

2. 向下取整和向上取整

3. 排名和选择

4. 范围查找

5. 例外情况

6. 便携方法

7. 键的等价性

    Java 的一条最佳实践就是维护所有 Comparable 类型中的 compareTo()方法和 equals()方法的一致性。

8. 成本模型

### 3.1.3 用例举例

1. 行为测试用例

2. 性能测试用例

### 3.1.4 无序链表中的顺序查找

在含有 N 对键值的无序链表的符号表中，未命中的查找和插入操作都需要 N 次比较；命中的查找在最坏情况下需要 N 次比较。特别地，向一个空表中插入 N 个不同的链需要(N\*N)/2 次比较。

### 3.1.5 有序数组中的二分查找

1. 二分查找

2. 其他操作

### 3.1.6 对二分查找的分析

**在 N 个键的有序数组中进行二分查找最多需要(lgN+1)次比较。**

## 3.2 二叉查找树

一棵二叉查找树(BST)是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。

二叉树示意：

![二叉树示意图](../resources/images/二叉树示意图.png)

二叉查找树示意：

![二叉查找树示意图](../resources/images/二叉查找树示意图.png)

### 3.2.1 基本实现

1. 数据表示

    二叉树结点表示：

    ```java
    private class Node {
        private Key key;        // 键
        private Value value;    // 值
        private Node left;      // 左子树
        private Node right;     // 右子树
        private int n;          // 结点总数
    }
    ```

2. 查找

二叉查找树查找命中：

![二叉查找树查找命中](../resources/images/二叉查找树查找命中.png)

二叉查找树查找未命中：

![二叉查找树查找未命中](../resources/images/二叉查找树查找未命中.png)

3. 插入

![二叉查找树插入操作](../resources/images/二叉查找树插入操作.png)

4. 递归

### 3.2.2 分析

二叉查找树的算法运行时间取决于树的形状，树的形状又取决于键被插入的先后顺序。

**在由 N 个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~2lnN（约为 1.39lgN）。**

**在由 N 个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN（约为 1.39lgN）。**

### 3.2.3 有序性相关的方法与删除操作

1. 最大键和最小键

![最大键](../resources/images/最大键.png)

![最小键](../resources/images/最小键.png)

2. 向上取整和向下取整

3. 选择操作

4. 排名

5. 删除最大键和删除最小键

删除最小键示例：

![删除最小键](../resources/images/删除最小键.png)

6. 删除操作

删除操作示例：

![删除操作](../resources/images/删除操作.png)

7. 范围查找

8. 性能分析

    **在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。**
