# 第 3 章 查找

## 3.1 符号表

符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，即将一组新的键值对存入表中；查找(get)，即根据给定的键得到相应的值。

### 3.1.1 API

|                 |                           |                                                  |
| --------------: | :------------------------ | :----------------------------------------------- |
|    public class | ST\<Key, value\>          |                                                  |
|                 | ST()                      | 创建一张符号表                                   |
|            void | put(Key key, Value value) | 将键值对存入表中（若值为空则将键 key 从表中删除) |
|           Value | get(Key key)              | 获取键 Key 对应的值（若键 key 不存在则抬 null)   |
|            void | delete(Key key)           | 从表中删去键 key（及其对应的值）                 |
|         boolean | contains(Key key)         | 键 key 在表中是否有对应的值                      |
|         boolean | isEmpty()                 | 表是否为空                                       |
|             int | size()                    | 表中的键值对数量                                 |
| Iterable\<Key\> | keys()                    | 表中的所有键的集合                               |

1. 泛型

2. 重复的键

    所有实现遵循以下规则：

    - 每个键只对应着一个值（表中不允许存在重复的键）
    - 每当代码向表中存入的键值对和表中已有的键冲突时，新的值会替代旧的值

3. 空键(null)

    键不能为空。

4. 空值(null)

    不允许有空值。

5. 删除操作

    - 延时删除：将键对应的值置为空，在某个时候删去所有值为空的健。
    - 即时删除：立刻从表中删除指定的键。

6. 便携方法

7. 迭代

8. 键的等价性

### 3.1.2 有序符号表

有序泛型符号表 API

|                 |                                            |                                                  |
| --------------: | :----------------------------------------- | :----------------------------------------------- |
|    public class | ST\<Key extends Comparable\<key\>, Value\> |                                                  |
|                 | ST()                                       | 创建一张符号表                                   |
|            void | put(Key key, Value value)                  | 将键值对存入表中（若值为空则将键 key 从表中删除) |
|           Value | get(Key key)                               | 获取键 Key 对应的值（若键 key 不存在则抬 null)   |
|            void | delete(Key key)                            | 从表中删去键 key（及其对应的值）                 |
|         boolean | contains(Key key)                          | 键 key 在表中是否有对应的值                      |
|         boolean | isEmpty()                                  | 表是否为空                                       |
|             int | size()                                     | 表中的键值对数量                                 |
|             Key | min()                                      | 最小的键                                         |
|             Key | max()                                      | 最大的键                                         |
|             Key | floor(Key key)                             | 小于等于 key 的最大键                            |
|             Key | ceiling(key key)                           | 大于等于 key 的最小键                            |
|             int | rank(Key key)                              | 小于 key 的键的数量                              |
|             Key | select(int k)                              | 排名为 k 的键                                    |
|            void | deleteMin()                                | 删除最小的键                                     |
|            void | deleteMax()                                | 删除最大的键                                     |
|             int | size(Key lo, Key hi)                       | \[lo..hi\]之间键的数量                           |
| Iterable\<Key\> | keys(Key lo, Key hi)                       | \[lo..hi]之间的所有键，已排序                    |
| Iterable\<Key\> | keys()                                     | 所有键的集合，已排序                             |

1. 最大键和最小键

2. 向下取整和向上取整

3. 排名和选择

4. 范围查找

5. 例外情况

6. 便携方法

7. 键的等价性

    Java 的一条最佳实践就是维护所有 Comparable 类型中的 compareTo()方法和 equals()方法的一致性。

8. 成本模型

### 3.1.3 用例举例

1. 行为测试用例

2. 性能测试用例

### 3.1.4 无序链表中的顺序查找

在含有 N 对键值的无序链表的符号表中，未命中的查找和插入操作都需要 N 次比较；命中的查找在最坏情况下需要 N 次比较。特别地，向一个空表中插入 N 个不同的链需要(N\*N)/2 次比较。

### 3.1.5 有序数组中的二分查找

1. 二分查找

2. 其他操作

### 3.1.6 对二分查找的分析

**在 N 个键的有序数组中进行二分查找最多需要(lgN+1)次比较。**
