# 第 6 章 背景

**商业应用**

-   基础设施（操作系统、数据库、通信）
-   应用程序（电子邮件、文档处理、数码照片）
-   出版（书籍、杂志、网络内容）
-   网络（无线网络、社交网络、互联网）
-   交易处理（金融、零售、网络搜索）

**科学计算**

-   数学计算（多项式、矩阵、微分方程）
-   数据处理（实验结果和观测资料，特别是基因组学）
-   计算模型和模拟

**工程学**

-   现代工程学

    -   数学计算和数据处理
    -   计算机辅助设计和生产
    -   基于算法的工程设计（网络、控制系统）
    -   图像和其他医学系统

-   运筹学

    -   任务调度
    -   决策
    -   资源分配

-   计算机科学

    -   计算几何
    -   密码学
    -   数据库
    -   编程语言与系统
    -   人工智能

### 6.0.1 事件驱动模拟

按照弹性碰撞模拟粒子系统的运动。

1. 刚性球体模型

2. 时间驱动模拟

3. 事件驱动模拟

4. 碰撞预测

5. 碰撞计算

6. 排除无效事件

7. 粒子

    运动的粒子对象 API

    |              |                                                                             |                                            |
    | -----------: | :-------------------------------------------------------------------------- | :----------------------------------------- |
    | public class | Particle                                                                    |                                            |
    |              | Particle()                                                                  | 在单位空间中创造一个新的随机粒子           |
    |              | Particle(double rx, double ry, double vx, double vy, double s, double mass) | 用给定的位置、速度、半径和质量创建一个粒子 |
    |         void | draw()                                                                      | 画出粒子                                   |
    |         void | move(double dt)                                                             | 根据时间的 dt 改变粒子的位置               |
    |          int | count()                                                                     | 该粒子所参与的碰撞总数                     |
    |       double | timeToHit(Particle b)                                                       | 距离该粒子和粒子 b 碰撞所需的时间          |
    |       double | timeToHitHorizontalWall()                                                   | 距离该粒子和水平墙体碰撞所需的时间         |
    |       double | timeToVerticalWall()                                                        | 距离该粒子和垂直墙体碰撞所需的时间         |
    |       double | bounceOff(Particle b)                                                       | 碰撞后该粒子的速度                         |
    |       double | bounceOffHorizontalWall()                                                   | 碰撞水平墙体后该粒子的速度                 |
    |       double | bounceOffVerticalWall()                                                     | 碰撞垂直墙体后该粒子的速度                 |

8. 事件

9. 模拟器代码

10. 性能

    对 N 个能够相互碰撞的粒子系统，基于事件的模拟在初始化时最多需要$N^2$次优先队列操作，在碰撞时最多需要 N 次优先队列操作。

### 6.0.2 B-树

1. 成本模型

    **B-树的成本模型**：使用页的访问次数（无论读写）作为外部查找算法的成本模型。

2. B-树

3. 约定

    外部查找的应用常会将索引和数据隔离。对于 B 树：

    - 内部结点：含有与页相关联的键的副本；
    - 外部结点：含有指向实际数据的引用。

4. 查找和插入

    B-树中查找的基础是在可能含有被查找键的唯一子树中进行递归搜索。

5. 数据表示

6. 性能

    含有 N 个元素的 M 阶 B-树中的一次查找或插入操作需要 $log_M{N}$~$log_{M/2}{N}$ 次探查，在实际情况中这基本是一个常数。

7. 空间需求

    B-树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间。

### 6.0.3 后缀数组

1. 最长重复子字符串

    - 代码重构
    - 计算生物学

2. 暴力解法

3. 后缀排序

    用 Java 的 substring()方法创建一个由字符串 s 的所有后缀字符串组成的数组，然后将该数组排序。排序后，最长重复子字符串会出现在数组中的相邻位置。

4. 定位字符串

5. API 及其用例

    后缀数组的 API

    |              |                          |                                             |
    | -----------: | :----------------------- | :------------------------------------------ |
    | public class | SuffixArray              |                                             |
    |              | SuffixArray(String text) | 为文本 text 构造后缀数组                    |
    |          int | length()                 | 文本 text 的长度                            |
    |       String | select(int i)            | 后缀数组中的第 i 个元素                     |
    |          int | index(int i)             | select(i)的索引                             |
    |          int | lcp(int i)               | select(i)和 select(i-1)的最长公共前缀的长度 |
    |          int | rank(String key)         | 小于键 key 的后缀数量                       |

6. 实现

7. 性能

    使用三向字符串快速排序，构造长度为 N 的随机字符串的后缀数组，平均所需的空间与 N 成正比，字符比较次数与 ~$2NlnN$ 成正比。

8. 改进的实现

    使用后缀数组，可以在线性时间内解决后缀排序和最长重复子字符串问题。

### 6.0.4 网络流算法

1. 物理模型

2. 定义

    一个**流量网络**是一张边的权重为正的加权有向图。一个**st-流量网络**有两个已知的顶点，即起点 s 和终点 t。

    - 流入量
    - 流出量
    - 净流量

3. API

    流量网络中的边的 API

    |              |                                        |                       |
    | -----------: | :------------------------------------- | :-------------------- |
    | public class | FlowEdge                               |                       |
    |              | FlowEdge(int v, int w, double cap)     |                       |
    |          int | from()                                 | 边的起始顶点          |
    |          int | to()                                   | 边的目的顶点          |
    |          int | other(int v)                           | 边的另一顶点          |
    |       double | capacity()                             | 边的容量              |
    |       double | flow()                                 | 边中的流量            |
    |       double | residualCapacityTo(int v)              | v 的剩余容量          |
    |       double | addResidualFlowTo(int v, double delta) | 将 v 的流量增加 delta |
    |       String | toString()                             | 对象的字符串表示      |

    流量网络的 API

    |                      |                     |                               |
    | -------------------: | :------------------ | :---------------------------- |
    |         public class | FlowNetwork         |                               |
    |                      | FlowNetwork(int V)  | 创建一个含有 V 个顶点的空网络 |
    |                      | FlowNetwork(In in)  | 从输入流中构造流量网络        |
    |                  int | V()                 | 顶点总数                      |
    |                  int | E()                 | 边的总数                      |
    |                 void | addEdge(FlowEdge e) | 向流量网络中添加边 e          |
    | Iterable\<FlowEdge\> | adj(int v)          | 从 v 指出的边                 |
    | Iterable\<FlowEdge\> | edges()             | 流量网络中的所有边            |
    |               String | toString()          | 对象的字符串表示              |

4. Ford-Fulkerson 算法

    算法思想：网络中的初始流量为零，沿着任意从起点到终点（且不含有饱和的正向边或是空逆向边）的增广路径增大流量，直到网络中不存在这样的路径为止。

5. 最大流－最小切分定理

    st-切分是一个将顶点 s 和顶点 t 分配于不同集合中的切分。

    对于任意 st-流量网络，每种 st-切分中的跨切分流量都和总流量的值相等。

    s 的流出量等于 t 的流入量。

    st-流量网络的值不可能超过任意 st-切分的容量。

6. 剩余网络

7. 最短增广路径算法

8. 性能

    最短增广路径的 Ford-Fulkerson 最大流量算法在处理含有 V 个顶点和 E 条边的流量网络时找到的增广路径最多为 EV/2 条。

9. 其他实现

### 6.0.5 问题归约

    如果能够用解决问题B的算法得到一个解决问题A的算法，则说问题A能够被归约为问题B。

1. 排序问题

    可以被归约为排序问题：

    - 寻找中位数
    - 统计不同的值
    - 最小平均完成时间的调度问题

2. 最短路径问题

    可以被归约为加权图中的最短路径问题：

    - 非负权重的无向图中的单点最短路径问题
    - 优先级限制下的并行调度问题
    - 套汇问题

3. 最大流量问题

    可以归约为最大流量问题：

    - 就业安置
    - 产品配送
    - 网络可靠性

4. 线性规划

    可归约为线性规划问题：

    - 最大流量问题
    - 最短路径问题
    - 许多许多其他问题
        - 添加约束条件和扩展线性规划模型非常简单
        - 问题的归约是有传递性的
        - 各种最优化问题都能够直接构造为线性规划问题

### 6.0.6 不可解性

1. 准备工作

2. 指数级别的运行时间

3. 搜索问题

    如果一个问题有解且验证它的解的正确性所需的时间不会超过输入规模的多项式，则称这种问题为搜索问题。当一个算法给出了一个解或是已证明解不存在时，就称它解决了一个搜索问题。

    NP 是所有搜索问题的集合。

4. 其他类型的问题

5. 简单的搜索问题

    P 是能够在多项式时间内解决的所有搜索问题的集合。

6. 非确定性

7. 主要问题

8. 多项式时间问题的相互归约

9. NP-完全性

    若 NP 中的所有问题都能在多项式时间内归约为搜索问题 A，那么则称问题 A 是 NP-完全的。

10. Cook-Levin 定理

    布尔可满足性问题是 NP-完全的。

11. 问题的分类

12. 处理 NP-完全性
