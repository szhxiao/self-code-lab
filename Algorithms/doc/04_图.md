# 第 4 章 图

## 4.1 无向图

**图是由一组顶点和一组能够将两个顶点相连的边组成的。**

特殊的图：

-   **自环**，即一条连接一个顶点和其自身的边；
-   连接同一对顶点的两条边为平行边。

![图示例](../resources/images/图示例.png)

### 4.1.1 术语表

-   相邻：两个顶点通过一条边相连，并称这条边**依附**于这两个顶点。
-   顶点的度数：依附于顶点的边的总数。
-   子图：由一幅图的所有边的一个子集组成的图。
-   路径：由边顺序连接的一系列顶点。
-   简单路径：一条没有重复顶点的路径。
-   环：一条至少含有一条边且起点和终点相同的路径。
-   简单环：一条（除了起点和终点必须相同外）不含有重复顶点和边的环。
-   路径长度：路径中包含的边数。
-   连通：两个顶点之间存在一条连接双方的路径。
-   图的密度：已经连接的顶点对占所有可能被连接的顶点对的比例。

1. 连通图

    从任意一个顶点都存在一条路径到达另一个任意顶点的图。

2. 非连通图

    由若干连通的部分组成，都是极大连通子图。

3. 树与图

    树是一幅无无环连通图。

    当且仅当一幅含有 V 个结点的图 G 满足下列条件之一时，它就是一棵树：

    - G 有 V-1 条边且不含有环；
    - G 有 V-1 条边且是连通的；
    - G 是连通的，但删除任意一条边都会使它不再连通；
    - G 是无环图，但添加任意一条边都会产生一条环；
    - G 中的任意一对顶点之间仅存在一条简单路径。

### 4.1.2 表示无向图的数据类型

无向图的 API

|                     |                       |                                     |
| ------------------: | :-------------------- | :---------------------------------- |
|        public class | Graph                 |                                     |
|                     | Graph(int V)          | 创建一个含有 V 个顶点但不含有边的图 |
|                     | Graph(In in)          | 从标准输入流 in 读入一幅图          |
|                 int | V()                   | 顶点数                              |
|                 int | E()                   | 边数                                |
|                void | addEdge(int v, int w) | 向图中添加一条边 v-w                |
| Iterable\<Integer\> | adj(int v)            | 和 v 相邻的所有顶点                 |
|              String | toString()            | 对象的字符串表示                    |

1. 图的几种表示法

    - 邻接矩阵

        使用 V\*V 的布尔矩阵，当顶点 v 和顶点 w 间有相连接的边时，定义 v 行 w 列的元素值为 true，否则为 false。

    - 边的数组

        使用一个 Edge 类，含有两个 int 实例变量。

    - 邻接表数组

        使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。

2. 邻接表的数据结构

    将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。

    实现的性能特点：

    - 使用的空间和 V+E 成正比；
    - 添加一条边所需的时间为常数；
    - 遍历顶点 v 的所有相邻顶点所需的时间和 v 的度数成正比。

3. 图的处理算法的设计模式

### 4.1.3 深度优先搜索

常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。

1. 走迷宫

    Tremaus 搜索：

    - 选择一条没有标记过的通道，在走过的路上铺一条绳子；
    - 标记所有第一次路过的路口和通道；
    - 当来到一个标记过的路口时用绳子回退到上个路口；
    - 当回退到的路口已没有可走的通道时继续回退。

2. 热身

    **深度优先搜索**算法，要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时：

    - 将它标记为已访问；
    - 递归地访问它的所有没有标记过的领居顶点。

    **深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。**

3. 单向通道

4. 跟踪深度优先搜索

    深度优先搜索遍历边和访问顶点的顺序与图的表示是有关的，而不只是与图的结构或是算法有关。

    ![深度优先搜索用例](../resources/images/深度优先搜索用例.png)

5. 深度优先搜索详细轨迹

    ![深度优先搜索轨迹](../resources/images/深度优先搜索轨迹.png)

### 4.1.4 寻找路径

**单点路径**：给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出这条路径。”等类似问题。

1. 实现

2. 详细轨迹

    ![使用深度优先搜索的轨迹](../resources/images/深度优先搜索寻找轨迹.png)

    **使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。**

### 4.1.5 广度优先搜索

**广度优先搜索**使用队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复步骤直到队列为空：

-   取队列中的下一个顶点 v 并标记它；
-   将与 v 相邻的所有未被标记过的顶点加入队列。

广度优先搜索轨迹：

![广度优先搜索轨迹](../resources/images/广度优先搜索轨迹.png)

**对于从 s 可达的任意顶点 v，广度优先搜索都能找到一条从 s 到 v 的最短路径。**

**广度优先搜索所需的时间在最坏情况下和 V+E 成正比。**

深度优先搜索和广度优先搜索的不同之处：

-   从数据结构中获取下一个顶点的规则，广度优先是最早加入的顶点，深度优先搜索是最晚加入的顶点；
-   深度优先搜索探索一幅图的方式是寻找离起点更远的顶点，广度优先搜索则会先覆盖起点附近的顶点；
-   深度优先搜索的路径通常较长且曲折，广度优先搜索的路径则短而直接。

### 4.1.6 连通分量

连通分量的 API

|              |                         |                        |
| ------------ | :---------------------- | :--------------------- |
| public class | CC                      |                        |
|              | GG(Graph G)             | 预处理构造函数         |
| boolean      | connected(int v, int w) | v 和 w 是否连通        |
| int          | count()                 | 连通分量数             |
| int          | id(int v)               | v 所在的连通分量标识符 |

1. 实现

    深度优先搜索的预处理使用的时间和空间与 V+E 成正比且可以在常数时间内处理关于图的连通性问题。

2. union-find 算法

    union-find 算法是一种动态算法，在完成只需要判断连通性或是需要完成大量连通性查询和插入操作混合等类似任务时使用。

    深度优先搜索则更适合实现图的抽象数据类型。

### 4.1.7 符号图

1. API

    |              |                                            |                                                         |
    | -----------: | :----------------------------------------- | :------------------------------------------------------ |
    | public class | SymbolGraph                                |                                                         |
    |              | SymbolGraph(String filename, String delim) | 根据 filename 指定的文件构造图，使用 delim 来分隔顶点名 |
    |      boolean | contains(String key)                       | key 是否为一个顶点                                      |
    |          int | index(String key)                          | key 的索引                                              |
    |       String | name(int v)                                | 索引 v 的顶点名                                         |
    |        Graph | G()                                        | 隐藏的 Graph 对象                                       |

2. 测试用例

3. 实现

4. 间隔的度数

## 4.2 有向图

在有向图中，边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。

### 4.2.1 术语

1. 定义

    一幅有方向性的图是由**一组顶点**和**一组有方向的边**组成的，每条有方向的边都连接着有序的一对顶点。

2. 出度

    一个顶点的出度为由该顶点指出的边的总数。

3. 入度

    一个顶点的入度为指向该顶点的边的总数。

4. 有向图顶点的关系

    - 没有边相连;
    - 存在从 v 到 w 的边 v-->w;
    - 存在从 w 到 v 的边 w-->v;
    - 既存在 v-->w 也存在 w-->v。

![有向图](../resources/images/有向图详解.png)

### 4.2.2 有向图的数据类型

有向图的 API

|                     |                       |                                       |
| ------------------: | :-------------------- | :------------------------------------ |
|        public class | Digraph               |                                       |
|                     | Digraph(int V)        | 创建一幅含有 V 个顶点但没有边的有向图 |
|                     | Digraph(In in)        | 从输入流 in 中读取一幅有向图          |
|                 int | V()                   | 顶点总数                              |
|                 int | E()                   | 边的总数                              |
|                void | addEdge(int v, int w) | 向有向图中添加一条边 v->w             |
| Iterable\<Integer\> | adj(int v)            | 由 v 指出的边所连接的所有顶点         |
|             Digraph | reverse()             | 该图的的反向图                        |
|              String | toString()            | 对象的字符串表示                      |

1. 有向图的表示

    用邻接表表示有向图，边 v->w 表示为顶点 v 所对应的邻接链表中包含一个 w 顶点。

2. 输入格式

3. 有向图取反

4. 顶点的符号名

### 4.2.3 有向图中的可达性

有向图的可达性 API

|              |                                                     |                                |
| -----------: | :-------------------------------------------------- | :----------------------------- |
| public class | DirectedDFS                                         |                                |
|              | DirectedDFS(Digraph G, int s)                       | 在 G 中找到从 s 可达的所有顶点 |
|              | DirectedDFS(Digraph G, Iterable\<Integer\> sources) |
|      boolean | marked(int v)                                       | v 是否可达                     |

**在有向图中，深度优先搜索标记由一个集合的顶点可达的所有顶点所需的时间与被标记的所有顶点出度之和成正比。**

1. 标记－清除的垃圾收集

2. 有向图的寻路

### 4.2.4 环和有向无环图

1. 调度问题

    一种应用广泛的模型是给定一组任务并安排它们的执行顺序，限制条件是这些任务的执行方法和起始时间。

    - 优先级限制下的调度问题
    - 拓扑排序

        给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。

2. 有向图中的环

    一般来说，如果有一个有优先级限制的问题中存在有向环，那么这个问题肯定是无解的。

    **有向无环图**就是一幅不含有有向环的有向图。

3. 顶点的深度优先次序与拓扑排序

    **当且仅当一幅有向图是无环图时它才能进行拓扑排序。**

    **一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。**

### 4.2.5 有向图中的强连通性

**强连通**：两个顶点 v 和 w 是互相可达。

1. 强连通分量

    强连通分量性质：

    - 自反性：任意顶点 v 和自己都强连通的；
    - 对称性：如果 v 和 w 是强连通的，那么 w 和 v 也是强连通的；
    - 传递性：如果 v 和 w 是强连通的且 w 和 x 也是强连通的，那么 v 和 x 也是强连通的。

2. 应用举例

3. Kosaraju 算法

4. 再谈可达性

    有向图 G 的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从 v 指向 w 的边当且仅当在 G 中 w 是从 v 可达的。

## 4.3 最小生成树

**图的生成树是它的一棵含有其所有顶点的无环连通子图**。一幅加权图的最小生成树是它的一棵权值（树中所有边的权值之和）最小的生成树。

一些约定：

-   只考虑连通图
-   边的权重不一定表示距离
-   边的权重可能是 0 或者负数
-   所有边的权重都各不相同

### 4.3.1 原理

1. 切分定理

    图的一种切分是将图的所有顶点分为两个非空且不重叠的两个集合。横切边是一条连接两个属于不同集合的顶点的边。

    **切分定理：** 在一幅加权图中，给定任意的切分，它的横切边中的权重最小都必然属于图的最小生成树。

2. 贪心算法

    **最小生成树的贪心算法：** 下面这种方法会将含有 V 个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了 V-1 条黑色边为止。

### 4.3.2 加权无向图的数据类型

-   加权边的 API

    |              |                                    |                      |
    | -----------: | :--------------------------------- | :------------------- |
    | public class | Edge implements Comparable\<Edge\> |                      |
    |              | Edge(int v, int w, double weight)  | 初始化构造函数       |
    |       double | weight()                           | 边的权重             |
    |          int | either()                           | 边两端的顶点之一     |
    |          int | other()                            | 另一个顶点           |
    |          int | compareTo(Edge that)               | 将这条边和 that 比较 |
    |       String | toString()                         | 对象的字符串表示     |

-   加权无向图的 API

    |                   |                        |                             |
    | ----------------: | :--------------------- | :-------------------------- |
    |      public class | EdgeWeightedGraph      |                             |
    |                   | EdgeWeightGraph(int V) | 创建一幅含有 V 个顶点的空图 |
    |                   | EdgeWeightGraph(In in) | 从输入流中读取图            |
    |               int | V()                    | 图的顶点数                  |
    |               int | E()                    | 图的边数                    |
    |              void | addEdge(Edge e)        | 向图中添加一条边 e          |
    |  Iterable\<Edge\> | adj(int v)             | 和 v 相关联的所有边         |
    | Iterable \<Edge\> | edges()                | 图的所有边                  |
    |            String | toString()             | 对象的字符串表示            |

1. 用权重来比较边

2. 平行边

3. 自环

### 4.3.3 最小生成树的 API 和测试用例

最小生成树的 API

|                  |                          |                    |
| ---------------: | :----------------------- | :----------------- |
|     public class | MST                      |                    |
|                  | MST(EdgeWeightedGraph G) | 构造函数           |
| Iterable\<Edge\> | edges()                  | 最小生成树的所有边 |
|           double | weight()                 | 最小生成树的权重   |

1. 测试用例

2. 测试数据

### 4.3.4 Prim 算法

**Prim 算法：** 每一步都会为一棵生长中的树添加一条边：一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入树中。

**Prim 算法能够得到任意加权连通图的最小生成树。**

1. 数据结构

    - 顶点
    - 边
    - 横切边

2. 维护横切边的集合

Prim 算法轨迹：

![Prim算法轨迹](../resources/images/Prim算法轨迹.png)

3. 实现

    - 延时实现
    - 即时实现

4. 运行时间

    Prim 算法的延时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间与 E 成正比，所需的时间与 ElogE 成正比（最坏情况）。

### 4.3.5 Prim 算法的即时实现

![Prim算法即时轨迹图](../resources/images/Prim算法即时轨迹.png)

Prim 算法的即时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间和 V 成正比，所需的时间和 ElogV 成正比。

### 4.3.6 Kruskal 算法

![Kruskal算法轨迹](../resources/images/Kruskal算法轨迹.png)

Kruskal 算法的延时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间与 E 成正比，所需的时间与 ElogE 成正比（最坏情况）。

### 4.3.7 展望

## 4.4 最短路径

**最短路径：**在一幅加权有向图中，从顶点 s 到顶点 t 的最短路径是所有从 s 到 t 的路径中的权重最小者。

**单点最短路径：**给定一幅加权有向图和一个起点 s，回答“从 s 到给定的目的顶点 v 是否存在一条有向路径？如果有，找出最短的那条路径。”

### 4.4.1 最短路径的性质

1. 需要解决的问题

    - 路径是有向的
    - 权重不一定等价于距离
    - 并不是所有顶点都是可达的
    - 负权重会使问题更复杂
    - 最短路径一般都是简单的
    - 最短路径不一定是唯一的
    - 可能存在平行边和自环

2. 最短路径树

    给定一幅加权有向图和一个顶点 s，以 s 为起点的一棵最短路径树是图的一幅子图，它包含 s 和从 s 可达的所有顶点。这棵有向树的根结点为 s，树的每条路径都是有向图中的一条最短路径。

### 4.4.2 加权有向图的数据结构

-   加权有向边的 API

    |              |                                           |                  |
    | -----------: | :---------------------------------------- | :--------------- |
    | public class | DirectedEdge                              |                  |
    |              | DirectedEdge(int v, int w, double weight) |                  |
    |       double | weight()                                  | 边的权重         |
    |          int | form()                                    | 指出边的顶点     |
    |          int | to()                                      | 边指向的顶点     |
    |       String | toString()                                | 对象的字符串表示 |

-   加权有向图的 API

    |                          |                          |                            |
    | -----------------------: | :----------------------- | :------------------------- |
    |             public class | EdgeWeightDigraph        |                            |
    |                          | EdgeWeightDigraph(int v) | 含有 V 个顶点的空有向图    |
    |                          | EdgeWeightDigraph(In in) | 从输入流中读取图的构造函数 |
    |                      int | V()                      | 顶点总数                   |
    |                      int | E()                      | 边的总数                   |
    |                     void | addEdge(DirectedEdge e)  | 将 e 添加到有向图中        |
    | Iterable\<DirectedEdge\> | adj(int v)               | 从 v 指出的边              |
    | Iterable\<DirectedEdge\> | edges()                  | 有向图中的所有边           |
    |                   String | toString()               | 对象的字符串表示           |

1. 最短路径的 API

    |                          |                                |                                                |
    | -----------------------: | :----------------------------- | :--------------------------------------------- |
    |             public class | SP                             |                                                |
    |                          | SP(EdgeWeightDigraph G, int s) | 构造函数                                       |
    |                   double | distTo(int v)                  | 从顶点 s 到 v 的距离，如果不存在则路径为无穷大 |
    |                  boolean | hasPathTo(int v)               | 是否存在从顶点 s 到 v 的路径                   |
    | Iterable\<DirectedEdge\> | pathTo(int v)                  | 从顶点 s 到 v 的路径，如果不存在为 null        |

2. 测试用例

3. 最短路径的数据结构

    - 最短路径树中的边
    - 到达起点的距离

4. 边的松弛

5. 顶点的松弛

6. 为用例准备的查询方法

### 4.4.3 最短路径算法的理论基础

1. 最优性条件

2. 验证

3. 通用算法

### 4.4.4 Dijkstra 算法

1. 数据结构

2. 换一个角度看问题

    在一幅含有 V 个顶点和 E 条边的加权有向图中，使用 Dijkstra 算法读者根结点为给定起点的最短路径树所需的空间与 V 成正比，时间与 ElogV 成正比（最坏情况下）。

3. 变种

    - 给定两点的最短路径
    - 任意顶点对之间的最短路径
    - 欧几里得图中的最短路径

### 4.4.5 无环加权有向图中的最短路径算法
