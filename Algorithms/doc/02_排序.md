# 第 2 章 排序

排序就是**将一级对象按照某种逻辑顺序重新排列的过程**。

## 2.1 初级排序算法

### 2.1.1 游戏规则

1. 验证

2. 运行时间

3. 额外的内存使用

    - 原地排序算法

        除了函数调用所需的栈和固定数目的实例变量之外无需额外内存

    - 其他排序算法

        需要额外内存空间来存储另一份数组副本

4. 数据类型

    compareTo()必须实现**全序关系**:

    - 自反性
    - 反对称性
    - 传递性

### 2.1.2 选择排序

算法思想：

-   找到数组中最小的元素
-   将它和数组的第一个元素交换位置
-   在剩下的元素中找到最小的元素，将其与数组第二个元素交换位置
-   如此往复，直到整个数组排序

算法特点：

-   运行时间和输入无关
-   数据移动是最少的

示例过程：

![选择排序示例](../resources/images/选择排序示例.png)

### 2.1.3 插入排序

算法思想：

算法特点：

-   所需时间取决于输入中元素的初始顺序

示例过程：

![插入排序示例](../resources/images/插入排序示例.png)

### 2.1.4 排序算法的可视化

### 2.1.5 比较两种排序算法

比较步骤：

-   实现并调试算法
-   分析算法的基本性质
-   对算法的相对性能作出猜想
-   用实验验证猜想

### 2.1.6 希尔排序

算法思想：

-   使数组中任意间隔为 h 的元素都是有序的。
-   一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。

示例过程：

![希尔排序示例过程](../resources/images/希尔排序示例.png)

## 2.2 归并排序

### 2.2.1 原地归并的抽象方法

```java
    public static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo;
        int j = mid + 1;

        // Copy a[lo...hi] to aux[lo...hi]
        for (int k = lo; k <= hi; k++) {
            aux[k] = a[k];
        }

        for (int k = lo; k <= hi; k++) {
            if (i > mid) {
                a[k] = aux[j++];
            } else if (j>hi) {
                a[k] = aux[i++];
            } else if (less(aux[j], aux[i])) {
                a[k] = aux[j++];
            } else {
                a[k] = aux[i++];
            }
        }
    }
```

原地归并示例：

![原地归并示例](../resources/images/原地归并示例.png)

### 2.2.2 自顶向下的归并排序

算法思想：

采用分治思想，如果算法能将两个子数组排序，它就能够通过归并两个子数组将整个数组排序。

算法特点：

-   优点：归并排序所需的时间和 NlgN 成正比。

-   缺点：辅助数组所使用的额外空间和 N 的大小成正比。

算法改进：

1. 对于小规模子数组使用插入排序

    用不同方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理就能改进整个算法。

2. 测试数组是否已经有序

3. 不将元素复制到辅助数组

### 2.2.3 自底向上的归并排序

算法思想：

先归并微型数组，再成对归并得到的子数组。

算法特点：

-   自底向上的归并排序比较适合用链表组织的数据。
-   归并排序是一种渐进最优的基于比较排序的算法。

### 2.2.4 排序算法的复杂度

**没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN 次比较将长度为 N 的数组排序。**
