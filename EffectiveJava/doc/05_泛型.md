# 第 5 章 泛型

## 第 23 条：请不要在新代码中使用原生态类型

使用原生态类型会在运行时导致异常，原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的，不要在新代码中使用。

## 第 24 条：消除非受检警告

要尽可能地消除每一个非受检警告。

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用`@SuppressWarnings("unchecked")`注解来禁止警告信息。

SuppressWarnings 注解可以用在任何粒度的级别中，但应该始终在尽可能小的范围中使用。**永远不要在整个类上使用 SuppressWarnings**

## 第 25 条：列表优先于数组

数组会在运行时才知道并检查元素类型约束，泛型则是通过擦除实现的。泛型只在编译时强化它们的类型信息，并在运行时丢弃。

数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。

## 第 26 条：优先考虑泛型

将类泛型化要给类的声明添加一个或者多个类型参数。

使用泛型比使用需要在客户端代码中进行转换的类型更加安全，只要时间允许，就把现有的类型都泛型化。

## 第 27 条：优先考虑泛型方法

编写泛型方法与编写泛型类型类似，要将方法声明修改为一个类型参数，并在方法中使用类型参数。声明类型参数的类型参数列表，处在方法的修饰符及其返回类型之间。

泛型方法无需明确指定类型参数的值。

应该确保新方法可以不用转换就能使用，通常意味着要将它们泛型化。

## 第 28 条：利用有限制通配符来提升 API 的灵活性

为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。

**PECS: producer-extends, consumer-super**

不要用通配符类型作为返回类型。

一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它。

## 第 29 条：优先考虑类型安全的异构容器
