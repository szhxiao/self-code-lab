# 第 2 章 创建和销毁对象

## 第 1 条：考虑用静态工厂方法代替构造器

类可以通过静态工厂方法来提供它的客户端，这样做的几大优势：

-   静态工厂方法与构造器不同的第一大优势在于，它们有名称

    当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重地选择名称以便突出它们之间的区别

-   静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象
-   静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象
-   在创建参数化类型实例时，静态工厂方法使代码变得更加简洁

静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。

服务提供者框架：多个服务提供者实现一个服务，系统为服务提供者的客户端朝代多个实现，并把他们从多个实现中解耦出来。

服务朝代者框架组件：

-   服务接口：提供者实现
-   提供者注册 API：系统用来注册实现，让客户端访问
-   服务访问 API：客户端用来获取服务的实例
-   服务提供者接口：提供者负责创建其服务实现的实例（可选）

静态工厂方法惯用名称：

-   valueOf
-   of
-   getInstance
-   newInstance
-   getType
-   newType

## 第 2 条：遇到多个构造器参数时要考虑用构造器

重叠构造器模式可行，但是当有许多参数时，客户端代码会很难编写，并且仍然较难阅读。

JavaBeans 模式，调用一个无参构造器来创建对象，然后调用 setter 方法来设置每个必要的参数，以及每个相关的可选参数。

JavaBeans 模式自身缺点：

-   在构造过程中 JavaBean 可能处于不一致的状态
-   阻止了把类做成不可变的可能

Builder 模式，不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个 builder 对象。

Builder 模式十分灵活，可以利用单个 builder 构建多个对象。

## 第 3 条：用私有构造器或者或者枚举类型强化 gleton 属性

## 第 4 条：通过私有构造器强化不可实例化的能力

企图通过将类做成抽象类来强制该类不可被实例化是行不通的。

## 第 5 条：避免创建不必要的对象

一般来说，最好能重用对象而不是在每次需要时就创建一个相同功能的新对象。重用方式既快速，又流行。

通常可以使用静态工厂方法以避免创建不必要的对象。

**要优先使用基本类型而不是装箱类型，要当心无意识的自动装箱。**

## 第 6 条：消除过期的对象引用

在支持垃圾回收的语言中，内存泄漏是很隐蔽的，修复方法是一旦对象引用已经过期，只需清空这些引用即可。

清空对象引用应该是一种例外，而不是一种规范行为。消除过期引用最好的方法是让包含该引用的变量结束其生命周期。

内存泄漏来源：

-   类是自己管理内存
-   缓存
-   监听器和其他回调

## 第 7 条：避免使用终结方法
