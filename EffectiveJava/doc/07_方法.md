# 第 7 章 方法

## 第 38 条：检查参数的有效性

绝大多数方法和构造器对于传递给它们的参数值都会有某些限制。应该在文档中清楚地指明所有这些限制，并且在方法体的开头处检查参数，以强制施加这些限制。

对于公有的方法，要用 Javadoc 的@throws 标签在文档中说明违反参数值限制时会抛出的异常。

非公有的方法通常应该使用断言（assertion）来检查它们的参数。

```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    ...
}
```

**每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。**

## 第 39 条：必要时进行保护性拷贝

保护性拷贝是在检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始对象。

-   对于构造器的每个可变参数进行保护性拷贝是必要的；
-   访问方法在进行保护性拷贝时允许使用 clone 方法。

**如果类具有从客户端提到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。**

## 第 40 条：谨慎设计方法签名

1.  谨慎地选择方法的名称

    方法的名称应该始终遵循标准的命名习惯：

    -   易于理解；
    -   与大众认可的名称相一致；

2.  不要过于追求提供便利的方法

    每个方法都应该尽其所能，只有当一项操作被经常用到的时候，才考虑为它提供快捷方式。

3.  避免过长的参数列表

    **目标是四个参数，或者更少。**

    缩短过长的参数列表的方法：

    -   把方法分解成多个方法，每个方法只需要参数的一个子集；
    -   创建辅助类，用来保存参数的分组；
    -   从对象构建到方法调用都采用 Builder 模式。

4.  对于 boolean 参数，要优先使用两个元素的枚举类型

## 第 41 条：慎用重载

当一个子类包含的方法声明与其祖先类中的方法声明具有同样的签名时，方法就被覆盖了。如果实例方法在子类中被覆盖了，并且这个方法是在该子类的实例上被调用的，那么子类中的覆盖方法将会执行，遭遇不管该子类实例的编译时类型到底是什么。

**安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。**

一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。

## 第 42 条：慎用可变参数

可变参数方法接受 0 个或者多个指定类型的参数。可变参数机制通过先创建一个数组，数组的大小为在调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。

**在重视性能的情况下，使用可变参数机制要特别小心。**可变参数方法的每次调用都会导致进行一次数组分配和初始化。

在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过滤滥用。如果使用不当，会产生混乱的结果。

## 第 43 条：返回零长度的数组或者集合，而不是 null

返回类型为数组或集合的方法没理由返回 null，而是返回一个零长度的数组或者集合。

## 第 44 条：为所有导出的 API 元素编写文档注释

为了正确地编写 API 文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。

方法的文档注释应该简洁地描述出它和客户端之间的约定。

为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。

**要为 API 编写文档，文档注释是最好、最有效的途径。**
