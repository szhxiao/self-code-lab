# 第 3 章 所有对象都通用的方法

## 第 8 条：覆盖 equals 时请遵守通用约定

1. equals 方法满足的条件

    - 类的每个实例本质上都是唯一的
    - 不关心类是否提供了“逻辑相等(logical equality)”的测试功能
    - 超类已经覆盖了 equals，从超类继承过来的行为对于子类也是合适的
    - 类是私有的或包级私有的，可以确定它的 equals 方法永远不会被调用

2. 覆盖 equals 方法时遵守的通用约定

    | 性质               | 说明                                                                                                                                             | 备注                                                                   |
    | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------- |
    | 自反性(reflexive)  | 对于任何非 null 的引用值 x，x.equals(x)必须返回 true                                                                                             | 对象必须等于其自身                                                     |
    | 对称性(symmetric)  | 对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x)返回 true 时，x.equals(y)必须返回 true                                                      | 任何两个对象对于“它们是否相等”的问题都必须保持一致                     |
    | 传递性(transitive) | 对于任何非 null 的引用值 x, y, z,如果 x.equals(y)返回 true，并且 y.equals(z)返回 true，那么 x.equals(z)也必须返回 true                           |                                                                        |
    | 一致性(consistent) | 对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y)就会一致地返回 true，或一致地返回 false | 如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象被修改了 |
    | 非空性             | 对于任何非 null 的引用值 x，x.equals(null)必须返回 false                                                                                         | 所有对象都必须不等于 null                                              |

3. 高质量实现 equals 的方法

    - 使用`==`操作符检查“参数是否为这个对象的引用”
    - 使用 instanceof 操作符检查“参数是否为正确的类型”
    - 把参数转换成正确的类型
    - 对于该类中的每个“关键(significant)”域，检查参数中的域是否与该对象中对应的域相匹配
    - 编写完成 equals 方法后，应该问自己三个问题：它是否是对称的、传递的、一致的？

4. Tips:

    - 覆盖 equals 时总要覆盖 hashCode
    - 不要企图让 equals 方法过于智能
    - 不要将 equals 声明中的 Object 对象替换为其他类型

## 第 9 条：覆盖 equals 时总要覆盖 hashCode

**每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。**

一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”。解决办法：

1. 把某个非零的常数值，比如 17，保存在一个名为 result 的 int 类型变量中。
2. 对于对象中每个关键域 f（指 equals 方法中涉及的每个域），完成以下步骤：
    - a. 为该域计算 int 类型的散列码 c:
        - 如果该域是 boolean 类型，则计算 f?1:0
        - 如果该域是 byte, char, short 或 int 类型，则计算(int)f
        - 如果该域是 long 类型，则计算(int)(f^(f>>>32))
        - 如果该域是 float 类型，则计算 Float.floatToIntBits(f)
        - 如果该域是 double 类型，则计算 Double.doubleToLongBits(f)，然后为得到的 long 类型值计算散列值
        - 如果该域是对象引用，并且类的 equals 方法通过递归地调用 equals 方式来比较这个域，则同样为这个域递归地调用 hashCode；如果需要更复杂的比较，则为这个域计算一个“范式”，然后针对范式调用 hashCode；如果这个域是 null，则返回 0
        - 如果该域是一个数组，则要把每一个元素当做单独的域来处理
    - b. 按照公式把计算得到的散列码合并到 result 中：result = 31 \* result + c
3. 返回 result
4. 写完 hashCode 后，问问自己“相等的实例是否都具有相等的散列码”。

**Tips:**

-   如果一个类是不可变的，并且计算散列码的开销较大，就应该考虑把散列码缓存在对象内部。
-   不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。
