# 第 3 章 所有对象都通用的方法

## 第 8 条：覆盖 equals 时请遵守通用约定

1. equals 方法满足的条件

    - 类的每个实例本质上都是唯一的
    - 不关心类是否提供了“逻辑相等(logical equality)”的测试功能
    - 超类已经覆盖了 equals，从超类继承过来的行为对于子类也是合适的
    - 类是私有的或包级私有的，可以确定它的 equals 方法永远不会被调用

2. 覆盖 equals 方法时遵守的通用约定

    | 性质               | 说明                                                                                                                                             | 备注                                                                   |
    | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------- |
    | 自反性(reflexive)  | 对于任何非 null 的引用值 x，x.equals(x)必须返回 true                                                                                             | 对象必须等于其自身                                                     |
    | 对称性(symmetric)  | 对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x)返回 true 时，x.equals(y)必须返回 true                                                      | 任何两个对象对于“它们是否相等”的问题都必须保持一致                     |
    | 传递性(transitive) | 对于任何非 null 的引用值 x, y, z,如果 x.equals(y)返回 true，并且 y.equals(z)返回 true，那么 x.equals(z)也必须返回 true                           |                                                                        |
    | 一致性(consistent) | 对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y)就会一致地返回 true，或一致地返回 false | 如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象被修改了 |
    | 非空性             | 对于任何非 null 的引用值 x，x.equals(null)必须返回 false                                                                                         | 所有对象都必须不等于 null                                              |

3. 高质量实现 equals 的方法

    - 使用`==`操作符检查“参数是否为这个对象的引用”
    - 使用 instanceof 操作符检查“参数是否为正确的类型”
    - 把参数转换成正确的类型
    - 对于该类中的每个“关键(significant)”域，检查参数中的域是否与该对象中对应的域相匹配
    - 编写完成 equals 方法后，应该问自己三个问题：它是否是对称的、传递的、一致的？

4. Tips:

    - 覆盖 equals 时总要覆盖 hashCode
    - 不要企图让 equals 方法过于智能
    - 不要将 equals 声明中的 Object 对象替换为其他类型

## 第 9 条：覆盖 equals 时总要覆盖 hashCode

**每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。**

一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”。解决办法：

1. 把某个非零的常数值，比如 17，保存在一个名为 result 的 int 类型变量中。
2. 对于对象中每个关键域 f（指 equals 方法中涉及的每个域），完成以下步骤：
    - a. 为该域计算 int 类型的散列码 c:
        - 如果该域是 boolean 类型，则计算 f?1:0
        - 如果该域是 byte, char, short 或 int 类型，则计算(int)f
        - 如果该域是 long 类型，则计算(int)(f^(f>>>32))
        - 如果该域是 float 类型，则计算 Float.floatToIntBits(f)
        - 如果该域是 double 类型，则计算 Double.doubleToLongBits(f)，然后为得到的 long 类型值计算散列值
        - 如果该域是对象引用，并且类的 equals 方法通过递归地调用 equals 方式来比较这个域，则同样为这个域递归地调用 hashCode；如果需要更复杂的比较，则为这个域计算一个“范式”，然后针对范式调用 hashCode；如果这个域是 null，则返回 0
        - 如果该域是一个数组，则要把每一个元素当做单独的域来处理
    - b. 按照公式把计算得到的散列码合并到 result 中：result = 31 \* result + c
3. 返回 result
4. 写完 hashCode 后，问问自己“相等的实例是否都具有相等的散列码”。

**Tips:**

-   如果一个类是不可变的，并且计算散列码的开销较大，就应该考虑把散列码缓存在对象内部。
-   不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。

## 第 10 条：始终要覆盖 toString

toString 的通用约定指出，被返回的字符串应该是一个“简洁的，但信息丰富，并且易于阅读的表达形式”，“建议所有的子类都覆盖这个方法”。

在实际应用中，toString 方法应该**返回对象中包含的所有值得关注的信息**；并为 toString 返回值中**包含的所有信息，提供一种编程式的访问途径**。

## 第 11 条：谨慎地覆盖 clone

1. 所有实现了 Cloneable 接口的类都应该用一个公有的方法覆盖 clone

    - 先调用 super.clone
    - 修正任何需要修正的域

2. 提供一个拷贝构造器或拷贝工厂

## 第12条：考虑实现Comparable接口

compareTo方法不但允许进行简单的等同性比较，而且允许执行顺序比较，还是个泛型。**类实现了Comparable接口，就表明它的实例具有内存的排序关系。**

compareTo方法的通用约定：

- 确保所有的x和y都满足sgn(x.compareTo(y) == -sgn(y.compareTo(x)))，这也暗示着当且仅当y.compareTo(x)抛出异常时，x.compareTo(y)才必须抛出异常；
- 确保比较关系是可传递的：(x.compareTo(y) > 0 && y.compareTo(z) > 0)暗示着x.compareTo(z) > 0;
- 确保x.compareTo(y) == 0暗示着所有的z都满足sgn(x.compareTo(z)) == sgn(y.compareTo(z));
- 强烈建议(x.compareTo(y) == 0) == (x.equals(y))，但并非绝对必要。一般说来，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。

违反compareTo约定的类也会破坏其他依赖于比较关系的类。

compareTo方法中域的比较是顺序比较，而不是等同性比较。如果一个类有多个关键域，必须从最关键的域开始，逐步进行到所有的重要域。

