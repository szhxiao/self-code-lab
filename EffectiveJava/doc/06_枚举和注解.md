# 第 6 章 枚举和注解

## 第 30 条：用 enum 代替 int 常量

枚举类型是指由一组固定的常量组成合法值的类型。

为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。

与枚举常量关联的有些行为，可能只需要用在定义了枚举的类或者包中。

如果一个枚举具有普遍适用性，它就应该成为一个顶层类；如果是被用在一个特定的顶层类中，就应该成为该顶层类的一个成员类。

特定于常量的方法实现可以与特定常量的数据结合起来。

枚举类型有一个自动产生的 valueOf(String)方法，它将常量的名字转变成常量本身。

枚举有下小的性能缺点，即装载和初始化枚举时会有空间和时间的成本。

**每当需要一组固定常量的时候应该使用枚举。**

## 第 31 条：用实例域代替序数

永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

## 第 32 条：用 EnumSet 代替位域

**因为枚举类型要用在集合中，所以没有两眼用位域来表示它。**

## 第 33 条：用 EnumMap 代替序数索引

最好不要用序数来索引数组，而要使用 EnumMap。如果你所表示的关系是多维的，就使用 EnumMap<..., EnumMap<...>>。

## 第 34 条：用接口模拟可伸缩的枚举

对于可伸缩的枚举类型，至少有一种具有说服力的用例，就是操作码。操作码是指它的元素表示在某种机器上的那些操作的枚举类型。

虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。

## 第 35 条：注解优先于命名模式

1. 命名模式的缺点

    - 文字拼写错误会导致失败；
    - 无法确保只用于相应的程序元素上；
    - 没有提供将参数值与程序元素关联起来的好方法。

2. 自定义注解

    如果是在编写一个需要程序员给源文件添加信息的工具，就要定义一组适当的注解类型。

所有程序员都应该使用 Java 平台所提供的预定义的注解类型。

## 第 36 条：坚持使用 Override 注解

应该在想要覆盖超类声明的每个方法声明中使用 Override 注解，编译器可以替你防止大量的错误。

## 第 37 条：用标记接口定义类型

标记接口是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。

如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。

如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。
