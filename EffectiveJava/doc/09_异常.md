# 第 9 章 异常

## 第 57 条：只针对异常的情况才使用异常

异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使它们这么做的 API。

## 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常

Java 语言提供了三种可抛出结构：受检的异常（checked exception）、运行时异常（run-time exception）和错误（error）。

对于可恢复的情况，使用受检的异常；对于程序错误，则使用运行时异常。

异常也是个完全意义上的对象，可以在它上面定义任意的方法，主要用途是为捕获异常的代码而提供额外的信息。

## 第 59 条：避免不必要地使用受检异常

1. IllegalArgumentException

    当调用者传递的参数不合适时抛出此异常。

2. IllegalStateException

    如果因为接收对象的状态而使调用非法时抛出此异常。

3. ConcurrentModificationException

    如果一个对象被设计为专用于单线程或者与外部同步机制配合使用，一旦发现它正在并并发地修改，就应该抛出此异常。

4. UnsupportedOperationException

    如果对象不支持所请求的操作，就会抛出这个异常。

## 第 60 条：优先使用标准的异常

## 第 61 条：抛出与抽象相对应的异常

异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。

处理来自低层异常的最好做法：在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常。次选方案是：让更高层来悄悄地绕开这些异常，从而将高层方法的调用者与低层的问题隔离开来。

## 第 62 条：每个方法抛出的异常都要有文档

要为你编写的每个方法所抛出的每个异常建立文档。对于未受检和受检的异常，以及对于抽象的和具体的方法也都一样。

## 第 63 条：在细节消息中包含能捕获失败的信息

## 第 64 条：努力使失败保持原子性

失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性。

1. 设计一个不可变的对象；
2. 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生；
3. 编写一段恢复代码（不常用）

## 第 65 条：不要忽略了异常
