# 第 11 章 序列化

序列化技术为远程通信提供了标准的线路级对象表示法，也为 JavaBeans 组件结构提供了标准的持久化数据格式。

## 第 74 条：谨慎地实现 Serializable 接口

实现 Serializable 接口的代价：

-   一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性；
-   增加了出现 bug 和安全漏洞的可能性；
-   随着类发行新的版本，相关的测试负担也增加了

为了继承而设计的类应该尽可能少地去实现 Serializable 接口，用户的接口也应该尽可能少地继承 Serializable 接口。

## 第 75 条：考虑使用自定义的序列化形式

当决定要将一个类做成可序列化的时候，应仔细考虑采用什么样的序列化形式。只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理地描述对象的状态。

## 第 76 条：保护性地编写 readObject 方法

编写 readObject 方法时都要这样想：你正在编写一个公有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。

编写出更加健壮的 readObject 方法：

-   对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象；
-   对于任何约束条件，如果检查失败，则抛出一个 InvalidObjectException 异常；
-   如果整个对象图在被反序列化之后必须进行验证，就应该使用 ObjectInputValidation 接口；
-   无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。

## 第 77 条：对于实例控制，枚举类型优先于 readResolve

应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个 readResolver 方法，并确保该类的所有实例域都为基本类型，或者是 transient 的。

## 第 78 条：考虑用序列化代理代替序列化实例

每当你发现自己必须在一个不能被客户端扩展的类上编写 readObject 或者 writeObject 方法时，就应该考虑使用序列化代理模式。

序列化代理模式：

-   为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态；
-   将 writeReplace 方法添加到外围类中

    ```java
    private Object writeReplace() {
        return new SerializationProxy(this);
    }
    ```

-   在 SerializationProxy 类中提供一个 readResolve 方法，它返回一个逻辑上相当的外围类实例
