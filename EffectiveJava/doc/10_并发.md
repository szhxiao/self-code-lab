# 第 10 章 并发

## 第 66 条：同步访问共享的可变数据

最佳办法：不共享可变数据。要么共享不可变的数据，要么压根不共享。

当多个线程共享可变数据的时候，每个读或写数据的线程都必须执行同步。如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。

## 第 67 条：避免过度同步

为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。

通常，你应该在同步区域内做尽可能少的工作。获得锁，检查共享数据，根据需要转换数据，然后放掉锁。

## 第 68 条：executor 和 task 优先于线程

你不仅应该尽量不要编写自己的工作队列，而且还应该尽量不直接使用线程。

## 第 69 条：并发工具优先于 wait 和 notify

直接使用 wait 和 notify 就像用“并发汇编语言”进行编程一样，而 java.util.concurrent 则提供了更高级的语言。

## 第 70 条：线程安全性的文档化

## 第 71 条：慎用延迟初始化

延迟初始化是延迟到需要域的值时才将它初始化的行为。

对于延迟初始化，最好建议“除非绝对必要，否则就不要这么做”。

大多数域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的个心初始化方法：

-   实例域：使用双重检查模式
-   静态域：使用 lazy initialization holder class idiom
-   可接受重复初始化的实例域：考虑使用单重检查模式

## 第 72 条：不要依赖于线程调度器

不要让应用程序的正确性依赖于线程调度器。否则，结果得到的应用程序将既不健壮，也不具有可移植性。

## 第 73 条：避免使用线程组

线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。
