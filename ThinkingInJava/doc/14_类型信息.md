# 类型信息

运行时类型信息使得你可以在程序运行时发现和使用类型信息。

## 为什么需要 RTTI

让代码只操纵对基类的引用。

使用 RTTI，可以查询某个基类引用所指向的对象的确切类型，然后选择或者剔除特例。

## Class 对象

类是程序的一部分，每个类都有一个 Class 对象。

所有类都是在第一次使用时，动态加载到 JVM 中的，即各个部分是在必需时才加载的。

一旦某个类的 Class 对象被载入内存，它就被用来创建这个类的所有对象。

1.  类字面常量

    建议使用.class 的形式，以保持与普通类的一致性。

    为了使用类而做的准备工作：

    -   加载：由类加载器执行，查找字节码，并从字节码中创建一个 Class 对象
    -   链接：验证类中的字节码，为静态域分配存储空间
    -   初始化：如果有超类，则对其进行初始化；执行静态初始化器和静态初始化块

2.  泛化的 Class 引用

3.  新的转型语法

## 类型转换前先做检查

RTTI 形式包括：

-   传统的类型转换
-   代表对象的类型 Class 对象
-   instanceof

1. 使用类字面常量

2. 动态的 instanceof

    Class.isInstance 方法提供了一种动态地测试对象的途径。

## instanceof 与 Class 的等价性

instanceof 和 isInstance()生成的结果完全一样，保持了类型概念；equals()和==也一样，没有考虑继承（要么是这个确切的类型，要么不是）。

## 反射：运行时的类信息

RTTI 和反射之间的区别：

-   RTTI：编译器在编译时撕开和检查.class 文件
-   反射：.class 文件在编译时是不可获取的，在运行时撕开和检查

## 动态代理

代理是基本的设计模式之一，是为了提供额外的或不同的操作而插入的用来代替实际对象的对象。

## 空对象

引入空对象的思想，它可以接受传递给它的所代表的对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。

空对象最有用之处在于它更靠近数据，对象表示的是问题空间内的实体。

##

​
